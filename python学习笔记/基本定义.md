##基本定义
 算法：算法犹如菜谱，告诉你如何完成特定的任务。从本质上说，编写计算机程序就是使用计算机能够理解的语言（如Python）描述一种算法。这种对机器友好的描述被称为程序，主要由表达式和语句组成。  
 表达式：表达式为程序的一部分，结果为一个值。例如，2 + 2就是一个表达式，结果为4。简单表达式是使用运算符（如+或%）和函数（如pow）将字面值（如2或"Hello"）组合起来得到的。通过组合简单的表达式，可创建复杂的表达式，如(2 + 2) *(3 - 1)。表达式还可能包含变量。  

 变量：变量是表示值的名称。通过赋值，可将新值赋给变量，如x = 2。赋值是一种语句。  

 语句：语句是让计算机执行特定操作的指示。这种操作可能是修改变量（通过赋值）、将信息打印到屏幕上（如print("Hello, world!")）、导入模块或执行众多其他任务。  

 函数：Python函数类似于数学函数，它们可能接受参数，并返回结果

 模块：模块是扩展，可通过导入它们来扩展Python的功能。例如，模块math包含多个很有用的函数。  

 程序：你通过练习学习了如何编写、保存和运行Python程序。  

 字符串：字符串非常简单。它们其实就是一段文本，其中的字符是用Unicode码点表示的。然而，对于字符串，需要学习的知识有很多。本章介绍了很多表示字符串的方式。

 序列：序列是一种数据结构，其中的元素带编号（编号从0开始）。列表、字符串和元组都属于序列，其中列表是可变的（你可修改其内容），而元组和字符串是不可变的（一旦创建，内容就是固定的）。要访问序列的一部分，可使用切片操作：提供两个指定切片起始和结束位置的索引。要修改列表，可给其元素赋值，也可使用赋值语句给切片赋值。

 成员资格：要确定特定的值是否包含在序列（或其他容器）中，可使用运算符in。将运算符in用于字符串时情况比较特殊——这样可查找子串。

 方法：一些内置类型（如列表和字符串，但不包括元组）提供了很多有用的方法。方法有点像函数，只是与特定的值相关联。方法是面向对象编程的一个重要方面，这将在第7章介绍。

 字符串格式设置：求模运算符（%）可用于将值合并为包含转换标志（如%s）的字符串，这让你能够以众多方式设置值的格式，如左对齐或右对齐，指定字段宽度和精度，添加符号（正号或负号）以及在左边填充0等。

 字符串方法：字符串有很多方法，有些很有用（如split和join），有些很少用到（如istitle和capitalize）。

 映射：映射让你能够使用任何不可变的对象（最常用的是字符串和元组）来标识其元素。Python只有一种内置的映射类型，那就是字典。

 将字符串格式设置功能用于字典：要对字典执行字符串格式设置作，不能使用format和命名参数，而必须使用format_map。

 字典方法：字典有很多方法，这些方法的调用方式与列表和字符串的方法相同。

 打印语句：你可使用print语句来打印多个用逗号分隔的值。如果print语句以逗号结尾，后续print语句将在当前行接着打印。

 导入语句：有时候，你不喜欢要导入的函数的名称——可能是因为你已将这个名称用作他用。在这种情况下，可使用import ... as ...语句在本地重命名函数。 

 赋值语句：通过使用奇妙的序列解包和链式赋值，可同时给多个变量赋值；而通过使用增强赋值，可就地修改变量。  

 代码块：代码块用于通过缩进将语句编组。代码块可用于条件语句和循环中，还可用于函数和类定义中（这将在本书后面介绍）。  
 条件语句：条件语句根据条件（布尔表达式）决定是否执行后续代码块。通过使用if/elif/else，可将多个条件语句组合起来。条件语句的一个变种是条件表达式，如a if b else c。  

 断言：断言断定某件事（一个布尔表达式）为真，可包含说明为何必须如此的字符串。如果指定的表达式为假，断言将导致程序停止执行（或引发第8章将介绍的异常）。最好尽早将错误揪出来，免得它潜藏在程序中，直到带来麻烦。  

 循环：你可针对序列中的每个元素（如特定范围内的每个数）执行代码块，也可在条件为真时反复执行代码块。要跳过代码块中余下的代码，直接进入下一次迭代，可使用continue语句；要跳出循环，可使用break语句。另外，你还可在循环末尾添加一个else子句，它将在没有执行循环中的任何break语句时执行。  

 推导：推导并不是语句，而是表达式。它们看起来很像循环，因此我将它们放在循环中讨论。通过列表推导，可从既有列表创建出新列表，这是通过对列表元素调用函数、剔除不想要的函数等实现的。推导功能强大，但在很多情况下，使用普通循环和条件语句也可完成任务，且代码的可读性可能更高。使用类似于列表推导的表达式可创建出字典。  

 pass、del、exec和eval：pass语句什么都不做，但适合用作占位符。del语句用于删除变量或数据结构的成员，但不能用于删除值。函数exec用于将字符串作为Python程序执行。函数eval计算用字符串表示的表达式并返回结果。

 抽象：抽象是隐藏不必要细节的艺术。通过定义处理细节的函数，可让程序更抽象。  

 函数定义：函数是使用def语句定义的。函数由语句块组成，它们从外部接受值（参数），并可能返回一个或多个值（计算结果）。  

 参数：函数通过参数（调用函数时被设置的变量）接收所需的信息。在Python中，参数有两类：位置参数和关键字参数。通过给参数指定默认值，可使其变成可选的。  

 作用域：变量存储在作用域（也叫命名空间）中。在Python中，作用域分两大类：全局作用域和局部作用域。作用域可以嵌套。  

 递归：函数可调用自身，这称为递归。可使用递归完成的任何任务都可使用循环来完成，但有时使用递归函数的可读性更高。  

 函数式编程：Python提供了一些函数式编程工具，其中包括lambda表达式以及函数map、filter和reduce。  

 对象：对象由属性和方法组成。属性不过是属于对象的变量，而方法是存储在属性中的函数。相比于其他函数，（关联的）方法有一个不同之处，那就是它总是将其所属的对象作为第一个参数，而这个参数通常被命名为self。  

 类：类表示一组（或一类）对象，而每个对象都属于特定的类。类的主要任务是定义其实例将包含的方法。  

 多态：多态指的是能够同样地对待不同类型和类的对象，即无需知道对象属于哪个类就可调用其方法。

 封装：对象可能隐藏（封装）其内部状态。在有些语言中，这意味着对象的状态（属性）只能通过其方法来访问。在Python中，所有的属性都是公有的，但直接访问对象的状态时程序员应谨慎行事，因为这可能在不经意间导致状态不一致。 

 继承：一个类可以是一个或多个类的子类，在这种情况下，子类将继承超类的所有方法。你可指定多个超类，通过这样做可组合正交（独立且不相关）的功能。为此，一种常见的做法是使用一个核心超类以及一个或多个混合超类。

 接口和内省：一般而言，你无需过于深入地研究对象，而只依赖于多态来调用所需的方法。然而，如果要确定对象包含哪些方法或属性，有一些函数可供你用来完成这种工作。

 抽象基类：使用模块abc可创建抽象基类。抽象基类用于指定子类必须提供哪些功能，却不实现这些功能。

 面向对象设计：关于该如何进行面向对象设计以及是否该采用面向对象设计，有很多不同的观点。无论你持什么样的观点，都必须深入理解问题，进而创建出易于理解的设计。

 异常对象：异常情况（如发生错误）是用异常对象表示的。对于异常情况，有多种处理方式；如果忽略，将导致程序终止。

 引发异常：可使用raise语句来引发异常。它将一个异常类或异常实例作为参数，但你也可提供两个参数（异常和错误消息）。如果在except子句中调用raise时没有提供任何参数，它将重新引发该子句捕获的异常。

 自定义的异常类：你可通过从Exception派生来创建自定义的异常。

 捕获异常：要捕获异常，可在try语句中使用except子句。在except子句中，如果没有指定异常类，将捕获所有的异常。你可指定多个异常类，方法是将它们放在元组中。如果向except提供两个参数，第二个参数将关联到异常对象。在同一条try/except语句中，可包含多个except子句，以便对不同的异常采取不同的措施。

 else子句：除except子句外，你还可使用else子句，它在主try块没有引发异常时执行。

 finally：要确保代码块（如清理代码）无论是否引发异常都将执行，可使用try/finally，并将代码块放在finally子句中。

 异常和函数：在函数中引发异常时，异常将传播到调用函数的地方（对方法来说亦如此）。

 警告：警告类似于异常，但（通常）只打印一条错误消息。你可指定警告类别，它们是Warning的子类。

 外部世界：外部世界可访问生成器的方法send，这个方法类似于next，但接受一个参数（要发送的“消息”，可以是任何对象）。

 生成器：在挂起的生成器内部，yield可能用作表达式而不是语句。换而言之，当生成器重新运行时，yield返回一个值——通过send从外部世界发送的值。如果使用的是next，yield将返回None。  
	请注意，仅当生成器被挂起（即遇到第一个yield）后，使用send（而不是next）才有意义。要在此之前向生成器提供信息，可使用生成器的函数的参数。

 新式类和旧式类：Python类的工作方式在不断变化。较新的Python 2版本有两种类，其中旧式类正在快速退出舞台。新式类是Python 2.2引入的，提供了一些额外的功能，如支持函数super和property，而旧式类不支持。要创建新式类，必须直接或间接地继承object或设置__metaclass__。

 魔法方法：Python中有很多特殊方法，其名称以两个下划线开头和结尾。这些方法的功能各不相同，但大都由Python在特定情况下自动调用。例如__init__是在对象创建后调用的。

 构造函数：很多面向对象语言中都有构造函数，对于你自己编写的每个类，都可能需要为它实现一个构造函数。构造函数名为__init__，在对象创建后被自动调用。

 重写：类可重写其超类中定义的方法（以及其他任何属性），为此只需实现这些方法即可。要调用被重写的版本，可直接通过超类调用未关联版本（旧式类），也可使用函数super来调用（新式类）。

 序列和映射：要创建自定义的序列或映射，必须实现序列和映射协议指定的所有方法，其中包括__getitem__和__setitem__等魔法方法。通过从list（或UserList）和dict（或UserDict）派生，可减少很多工作量。

 迭代器：简单地说，迭代器是包含方法__next__的对象，可用于迭代一组值。没有更多的值可供迭代时，方法__next__应引发StopIteration异常。可迭代对象包含方法__iter__，它返回一个像序列一样可用于for循环中的迭代器。通常，迭代器也是可迭代的，即包含返回迭代器本身的方法__iter__。

 生成器：生成器的函数是包含关键字yield的函数，它在被调用时返回一个生成器，即一种特殊的迭代器。要与活动的生成器交互，可使用方法send、throw和close。

 八皇后问题：八皇后问题是个著名的计算机科学问题，使用生成器可轻松地解决它。这个问题要求在棋盘上放置8个皇后，并确保任何两个皇后都不能相互攻击。

 类似于文件的对象：类似于文件的对象是支持read和readline（可能还有write和
writelines）等方法的对象。  

 打开和关闭文件：要打开文件，可使用函数open，并向它提供一个文件名。如果要确保即
便发生错误时文件也将被关闭，可使用with语句。

 模式和文件类型：打开文件时，还可指定模式，如'r'（读取模式）或'w'（写入模式）。
通过在模式后面加上'b'，可将文件作为二进制文件打开，并关闭Unicode编码和换行符
替换。

 标准流：三个标准流（模块sys中的stdin、stdout和stderr）都是类似于文件的对象，它
们实现了UNIX标准I/O机制（Windows也提供了这种机制）。

 读取和写入：要从文件或类似于文件的对象中读取，可使用方法read；要执行写入操作，
可使用方法write。

 读取和写入行：要从文件中读取行，可使用readline和readlines；要写入行，可使用writelines。

 迭代文件内容：迭代文件内容的方法很多，其中最常见的是迭代文本文件中的行，这可
通过简单地对文件本身进行迭代来做到。还有其他与较旧Python版本兼容的方法，如使用
readlines。


----------

##面向对象设计
 将相关的东西放在一起。如果一个函数操作一个全局变量，最好将它们作为一个类的属性和方法。

 不要让对象之间过于亲密。方法应只关心其所属实例的属性，对于其他实例的状态，让它们自己去管理就好了。

 慎用继承，尤其是多重继承。继承有时很有用，但在有些情况下可能带来不必要的复杂性。要正确地使用多重继承很难，要排除其中的bug更难。

 保持简单。让方法短小紧凑。一般而言，应确保大多数方法都能在30秒内读完并理解。对于其余的方法，尽可能将其篇幅控制在一页或一屏内。确定需要哪些类以及这些类应包含哪些方法时，尝试像下面这样做。  
(1) 将有关问题的描述（程序需要做什么）记录下来，并给所有的名词、动词和形容词加上标记。  
(2) 在名词中找出可能的类。  
(3) 在动词中找出可能的方法。  
(4) 在形容词中找出可能的属性。  
(5) 将找出的方法和属性分配给各个类。  
有了面向对象模型的草图后，还需考虑类和对象之间的关系（如继承或协作）以及它们的职
责。为进一步改进模型，可像下面这样做。  
(1) 记录（或设想）一系列用例，即使用程序的场景，并尽力确保这些用例涵盖了所有的功能。  
(2) 透彻而仔细地考虑每个场景，确保模型包含了所需的一切。如果有遗漏，就加上；如果
有不太对的地方，就修改。不断地重复这个过程，直到对模型满意为止。



----------
##分叉
**分叉**是一个UNIX术语。对进程（运
行的程序）进行分叉时，基本上是复制它，而这样得到的两个进程都将从当前位置开始继续往
下执行，且每个进程都有自己的内存副本（变量等）。原来的进程为父进程，复制的进程为子
进程。如果你是科幻小说迷，可将它们视为并行的宇宙：分叉操作在时间轴上创建一个分
支，最终得到两个独立存在的宇宙（进程）。所幸进程能够判断它们是原始进程还是子进程（通
常查看函数fork的返回值），因此能够执行不同的操作。（如果不能，两个进程将做同样的事
情，这除了让计算机陷入停顿外还有什么意义？）
在分叉服务器中，对于每个客户端连接，都将通过分叉创建一个子进程。父进程继续监听新连接，而子进程负责处理客户端请求。客户端请求结束后，子进程直接退出。由于分叉出来的进程并行地运行，因此客户端无需等待。鉴于分叉占用的资源较多（每个分叉出来的进程都必须有自己的内存），还有另一种解决方案：线程化。

---------
##线程
**线程**是轻量级进程（子进程），都位于同一个进程中并共享内存。这减少了占
用的资源，但也带来了一个缺点：由于线程共享内存，你必须确保它们不会彼此干扰或同时
修改同一项数据，否则将引起混乱。这些问题都属于同步问题。在现代操作系统（不支持分叉
的Windows除外）中，分叉的速度其实非常快，较新的硬件能够更好地应付其资源消耗。如果
你不想处理麻烦的同步问题，分叉可能是不错的选择。
然而，如果能够完全杜绝并行性，就再好不过了。在本章中，将介绍基于函数select的其
他解决方案。另一种避免线程和分叉的办法是使用Stackless Python（[http://stackless.com](http://stackless.com)），它是
一个能够快速而轻松地在不同上下文之间切换的Python版本。它支持一种类似于线程的并行方
式，名为微线程，其可伸缩性比真正的线程高得多。例如，“星战前夜在线”（EVEOnline，[http://www.eve-online.com](http://www.eve-online.com)）用Stackless Python微线程为数以千计的用户提供服务。