#方法

----------

**统一写成 *.方法()* 格式**


----------

##列表
1. append 用于将一个对象附加到列表末尾。   


2. clear 就地清空列表的内容。 


3. copy 复制列表。
 
4. count 计算指定的元素在列表中出现了多少次。

5. extend 让你能够同时将多个值附加到列表末尾，为此可将这些值组成的序列作为参数提供给方法extend。换而言之，你可使用一个列表来扩展另一个列表。
6. index 在列表中查找指定值第一次出现的索引。

7. insert 用于将一个对象插入列表。

8. pop 从列表中删除一个元素（末尾为最后一个元素），**并返回这一元素。**

9. remove 用于删除第一个为指定值的元素。

10. reverse 按相反的顺序排列列表中的元素

11. sort 用于对列表就地排序①。就地排序意味着对原来的列表进行修改，使其元素按顺序排列，而不是返回排序后的列表的副本。

----------

##字符串
1. format 使用这种方法时，每个替换字段都用花括号括起，其中可能包含名称，还可能包含有关如何对相应的值进行转换和格式设置的信息。替换字段没有名称或将索引用作名称。

2. center 通过在两边添加填充字符（默认为空格）让字符串居中。

3. find 在字符串中查找子串。如果找到，就返回子串的第一个字符的索引，否则返回-1。

4. join 是一个非常重要的字符串方法，其作用与split相反，用于合并序列的元素。

5. lower 返回字符串的小写版本。

6. title 将字符串转换为词首大写，即所有单词的首字母都大写，其他字母都小写。

7. replace 将指定子串都替换为另一个字符串，并返回替换后的结果。

8. split 是一个非常重要的字符串方法，其作用与join相反，用于将字符串拆分为序列。

9. strip将字符串开头和末尾的空白（但不包括中间的空白）删除，并返回删除后的结果。

10. translate与replace一样替换字符串的特定部分，但不同的是它只能进行单字符替换。这个方法的优势在于能够同时替换多个字符，因此效率比replace高。  
 - 使用translate前必须创建一个转换表。这个转换表指出了不同Unicode码点之间的转换关系。
 - 要创建转换表，可对字符串类型str调用方法maketrans，这个方法接受两个参数：  
	两个长度相同的字符串，它们指定要将第一个字符串中的每个字符都替换为第二个字符串中的相应字符。

----------

##字典
1. clear删除所有的字典项，这种操作是就地执行的（就像list.sort一样），因此什么都不返回（或者说返回None）。

2. copy返回一个新字典，其包含的键-值对与原来的字典相同（这个方法执行的是浅复制，因为值本身是原件，而非副本）。  
 - 如果修改副本中的值（就地修改而不是替换），原件也将发生变化，因为原件指向的也是被修改的值。  
 - 为避免这种问题，一种办法是执行深复制，即同时复制值及其包含的所有值，等等。为此，可使用模块copy中的函数deepcopy。

3. fromkeys创建一个新字典，其中包含指定的键，且每个键对应的值都是None。

4. get为访问字典项提供了宽松的环境。通常，如果你试图访问字典中没有的项，将引发错误。

5. items返回一个包含所有字典项的列表，其中每个元素都为(key, value)的形式。字典项在列表中的排列顺序不确定。

6. keys返回一个字典视图，其中包含指定字典中的键。

7. pop可用于获取与指定键相关联的值，并将该键-值对从字典中删除。

8. popitem类似于list.pop，但list.pop弹出列表中的最后一个元素，而popitem随机地弹出一个字典项，因为字典项的顺序是不确定的，没有“最后一个元素”的概念。如果你要以高效地方式逐个删除并处理所有字典项，这可能很有用，因为这样无需先获取键列表。

9. setdefault有点像get，因为它也获取与指定键相关联的值，但除此之外，setdefault还在字典不包含指定的键时，在字典中添加指定的键-值对。

10.  update使用一个字典中的项来更新另一个字典。

11.  values返回一个由字典中的值组成的字典视图。不同于方法keys，方法values返回的视图可能包含重复的值。

----------

##循环

1. break 结束（跳出）循环

2. continue 它结束当前迭代，并跳到下一次迭代开头。这基本上意味
着跳过循环体中余下的语句，但不结束循环。这在循环体庞大而复杂，且存在多个要跳过它的原因时很有用。在这种情况下，可使用continue

3. while True/break成例  

----------

##元素（item）
1. __len__(self)：这个方法应返回集合包含的项数，对序列来说为元素个数，对映射来说为键-值对数。如果__len__返回零（且没有实现覆盖这种行为的__nonzero__），对象在布尔上下文中将被视为假（就像空的列表、元组、字符串和字典一样）。

2. __getitem__(self, key)：这个方法应返回与指定键相关联的值。对序列来说，键应该是0~n 1的整数（也可以是负数，这将在后面说明），其中n为序列的长度。对映射来说，键可以是任何类型。
 
3. __setitem__(self, key, value)：这个方法应以与键相关联的方式存储值，以便以后能够使用__getitem__来获取。当然，仅当对象可变时才需要实现这个方法。

4. __delitem__(self, key)：这个方法在对对象的组成部分使用__del__语句时被调用，应删除与key相关联的值。同样，仅当对象可变（且允许其项被删除）时，才需要实现这个方法。  
 
  1. 对于序列，如果键为负整数，应从末尾往前数。换而言之，x[-n]应与x[len(x)-n]等效。

 2. 如果键的类型不合适（如对序列使用字符串键），可能引发TypeError异常。
 
 3. 对于序列，如果索引的类型是正确的，但不在允许的范围内，应引发IndexError异常。要了解更复杂的接口和使用的抽象基类（Sequence），请参阅有关模块collections的文档。

5. __getattribute__(self, name)：在属性被访问时自动调用（只适用于新式类）。
 
6. __getattr__(self, name)：在属性被访问而对象没有这样的属性时自动调用。

7. __setattr__(self, name, value)：试图给属性赋值时自动调用。

8. __delattr__(self, name)：试图删除属性时自动调用。  


1. 方法throw：用于在生成器中（yield表达式处）引发异常，调用时可提供一个异常类型、一个可选值和一个traceback对象。

2. 方法close：用于停止生成器，调用时无需提供任何参数。
3. 